<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Get-Homepage Mappings Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #1a202c; color: #e2e8f0; }
        .card, .input-group { background-color: #2d3748; }
        .btn { transition: background-color 0.2s; }
        .btn-primary { background-color: #4299e1; }
        .btn-primary:hover { background-color: #3182ce; }
        .btn-secondary { background-color: #667eea; }
        .btn-secondary:hover { background-color: #5a67d8; }
        input, textarea { background-color: #4a5568; }
        .field-tag {
            background-color: #4a5568;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .field-tag:hover { background-color: #718096; }
        .notification {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 1rem 2rem; border-radius: 0.5rem; color: white; z-index: 50;
            opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        .notification.show { opacity: 1; }
        .notification.success { background-color: #38a169; }
        .notification.error { background-color: #c53030; }
    </style>
</head>

<body class="h-screen flex flex-col">
    <header class="p-4 border-b border-gray-700">
        <div class="max-w-full mx-auto flex justify-between items-center">
            <h1 class="text-2xl md:text-4xl font-bold">Mappings Editor</h1>
            <div class="flex items-center space-x-4">
                <a href="/editor" class="text-blue-400 hover:text-blue-300">&larr; Config Editor</a>
                <a href="/editor/debug-raw" class="text-blue-400 hover:text-blue-300">Raw Data Viewer &rarr;</a>
                <a href="/" class="text-blue-400 hover:text-blue-300">&larr; Back to Media Manager</a>
            </div>
        </div>
    </header>

    <main class="flex-grow flex flex-col md:flex-row overflow-hidden p-4 gap-4">
        <!-- Left Navigation Panel -->
        <div class="w-full md:w-1/4 flex-shrink-0">
            <div id="navigation-panel" class="card p-4 rounded-lg shadow-lg h-full overflow-y-auto">
                <!-- Navigation links will be injected here -->
            </div>
        </div>

        <!-- Right Editor Panel -->
        <div class="w-full md:w-3/4 flex flex-col">
            <div id="editor-panel" class="card p-6 rounded-lg shadow-lg flex-grow overflow-y-auto">
                <!-- Editor for the selected mapping will be injected here -->
                <div class="text-center text-gray-400">
                    <p class="text-xl">Select a mapping from the left to begin editing.</p>
                </div>
            </div>
            <div class="mt-8 flex justify-end space-x-4">
                <button id="reset-button" class="btn btn-secondary font-bold py-2 px-4 rounded">Reset to Defaults</button>
                <button id="save-button" class="btn btn-primary font-bold py-2 px-4 rounded">Save Mappings</button>
            </div>
        </div>
    </main>

    <div id="notification" class="notification"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const navigationPanel = document.getElementById('navigation-panel');
            const editorPanel = document.getElementById('editor-panel');
            const saveButton = document.getElementById('save-button');
            const resetButton = document.getElementById('reset-button');
            const notification = document.getElementById('notification');
            let currentMappings = {}; // Store the loaded mappings in memory
            let lastFocusedInput = null; // Track the last focused input field

            const showNotification = (message, isError = false) => {
                notification.textContent = message;
                notification.className = `notification ${isError ? 'error' : 'success'} show`;
                setTimeout(() => { notification.classList.remove('show'); }, 3000);
            };

            const buildNavigation = (mappings) => {
                let navHtml = '<div class="space-y-4">';
                for (const [source, types] of Object.entries(mappings)) {
                    navHtml += `<div>
                                    <h2 class="text-xl font-bold capitalize mb-2 text-gray-300">${source}</h2>
                                    <ul class="space-y-1">`;
                    for (const [type, config] of Object.entries(types)) {
                        // Format the type for display: replace underscores, split camelCase, and capitalize each word.
                        const typeName = type
                            .replace(/_/g, ' ') // Replace underscores with spaces
                            .replace(/([a-z])([A-Z])/g, '$1 $2') // Split camelCase
                            .split(' ')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');
                        navHtml += `<li>
                                        <a href="#" class="nav-link block p-2 rounded hover:bg-gray-600" data-source="${source}" data-type="${type}">${typeName}</a>
                                    </li>`;
                    }
                    navHtml += `</ul></div>`;
                }
                navHtml += '</div>';
                navigationPanel.innerHTML = navHtml;
            };

            const buildEditorPanel = (source, type, config) => {
                // First, save any pending changes from the currently displayed editor
                updateMappingsFromUI();

                const fieldsHtml = config.fields.map(field =>
                    `<span class="field-tag inline-block rounded-full px-3 py-1 text-sm font-semibold mr-2 mb-2" data-field="${field}">{${field}}</span>`
                ).join('');

                let editorHtml = `<div class="mapping-item" data-source="${source}" data-type="${type}">
                                    <h3 class="text-xl font-semibold capitalize mb-4">${type.replace(/([A-Z])/g, ' $1').trim()}</h3>`;

                if (config.templates && typeof config.templates === 'object') {
                    for (const [templateKey, templateValue] of Object.entries(config.templates)) {
                        editorHtml += `<div class="mb-4">
                                         <label class="block text-sm font-medium text-gray-300 mb-1 capitalize">${templateKey}:</label>
                                         <input type="text" class="template-input w-full p-2 rounded font-mono" data-template-key="${templateKey}" value="${templateValue}">
                                       </div>`;
                    }
                } else {
                    editorHtml += `<div class="mb-4">
                                     <label class="block text-sm font-medium text-gray-300 mb-1">Template:</label>
                                     <input type="text" class="template-input w-full p-2 rounded font-mono" value="${config.template}">
                                   </div>`;
                }

                editorHtml += `<div class="mt-4">
                                 <p class="text-sm text-gray-400 mb-2">Available fields (click to insert):</p>
                                 <div class="flex flex-wrap">${fieldsHtml}</div>
                             </div>
                           </div>`;

                editorPanel.innerHTML = editorHtml;
            };

            const loadMappings = async (useDefaults = false) => {
                try {
                    const [savedMappingsRes, defaultMappingsRes] = await Promise.all([
                        fetch('/editor/api/mappings'),
                        fetch('/editor/api/mappings/default')
                    ]);

                    if (!savedMappingsRes.ok || !defaultMappingsRes.ok) {
                        throw new Error('Failed to fetch mapping configurations.');
                    }

                    const savedMappings = await savedMappingsRes.json();
                    const defaultMappings = await defaultMappingsRes.json();

                    // Deep merge defaults into saved mappings to ensure new fields/types are always present.
                    // This prevents the UI from breaking if a user's saved mappings.yaml is outdated.
                    const mergedMappings = JSON.parse(JSON.stringify(defaultMappings)); // Start with a copy of defaults
                    for (const source in savedMappings) {
                        if (!mergedMappings[source]) {
                            mergedMappings[source] = {};
                        }
                        for (const type in savedMappings[source]) {
                            if (!mergedMappings[source][type]) {
                                mergedMappings[source][type] = {};
                            }
                            // Merge the properties of the type (template, templates, fields)
                            Object.assign(mergedMappings[source][type], savedMappings[source][type]);
                            // If the saved mapping has a 'templates' object, ensure it's fully merged
                            if (savedMappings[source][type].templates && mergedMappings[source][type].templates) {
                                Object.assign(mergedMappings[source][type].templates, savedMappings[source][type].templates);
                            }
                        }
                    }


                    // If 'useDefaults' is true, we use the pure default mappings. Otherwise, use the merged result.
                    const mappings = useDefaults ? defaultMappings : mergedMappings;
                    currentMappings = mappings;
                    buildNavigation(mappings);
                    if (useDefaults) {
                        editorPanel.innerHTML = `<div class="text-center text-gray-400"><p class="text-xl">Defaults loaded. Select a mapping to view and then click 'Save Mappings'.</p></div>`;
                    }
                } catch (e) {
                    showNotification('Failed to load mappings.', true);
                }
            };

            const updateMappingsFromUI = () => {
                const activeItem = editorPanel.querySelector('.mapping-item');
                if (!activeItem) return; // Nothing to save if no editor is displayed

                const source = activeItem.dataset.source;
                const type = activeItem.dataset.type;

                if (currentMappings[source] && currentMappings[source][type]) {
                    const templateInputs = activeItem.querySelectorAll('.template-input');
                    if (templateInputs.length > 1 || (templateInputs.length === 1 && templateInputs[0].dataset.templateKey)) {
                        templateInputs.forEach(input => {
                            const key = input.dataset.templateKey;
                            currentMappings[source][type].templates[key] = input.value;
                        });
                    } else if (templateInputs.length === 1) {
                        currentMappings[source][type].template = templateInputs[0].value;
                    }
                }
            };

            const collectAllMappings = () => {
                updateMappingsFromUI(); // Ensure the currently displayed editor's values are saved
                const updatedMappings = JSON.parse(JSON.stringify(currentMappings)); // Return a clean copy

                // This part is now simplified as we update the 'currentMappings' object directly.
                // The original logic iterated the whole DOM, which is no longer necessary.
                // We just need to ensure the final state of the in-memory object is correct.
                Object.keys(updatedMappings).forEach(source => {
                    Object.keys(updatedMappings[source]).forEach(type => {
                        // Ensure 'fields' are not saved in the final output, as they are for UI only.
                        // A better approach is to construct the payload from scratch, but for now this is fine.
                        // Let's rebuild the object to be safe.
                    });
                });

                // Rebuild the object to be saved, excluding the 'fields' property.
                const mappingsToSave = {};
                for (const source in currentMappings) {
                    mappingsToSave[source] = {};
                    for (const type in currentMappings[source]) {
                        const { fields, ...configToSave } = currentMappings[source][type];
                        mappingsToSave[source][type] = configToSave;
                    }
                }
                return mappingsToSave;
            };

            saveButton.addEventListener('click', async () => {
                const mappingsToSave = collectAllMappings();
                try {
                    const response = await fetch('/editor/api/mappings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(mappingsToSave)
                    });
                    const result = await response.json();
                    showNotification(result.message, !response.ok);
                    if (response.ok) {
                        // Reload mappings to reflect the saved state cleanly
                        loadMappings();
                    }
                } catch (e) {
                    showNotification('Error saving mappings.', true);
                }
            });

            resetButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to reset all mappings to their default values? This will not save until you click "Save Mappings".')) {
                    loadMappings(true);
                }
            });

            navigationPanel.addEventListener('click', (e) => {
                if (e.target.classList.contains('nav-link')) {
                    e.preventDefault();
                    const source = e.target.dataset.source;
                    const type = e.target.dataset.type;
                    
                    // Highlight active link
                    navigationPanel.querySelectorAll('.nav-link').forEach(link => link.classList.remove('bg-blue-600', 'text-white'));
                    e.target.classList.add('bg-blue-600', 'text-white');

                    if (currentMappings[source] && currentMappings[source][type]) {
                        buildEditorPanel(source, type, currentMappings[source][type]);
                    }
                }
            });

            editorPanel.addEventListener('click', (e) => {
                if (e.target.classList.contains('field-tag')) {
                    e.preventDefault(); // Prevent loss of focus from the input
                    const field = e.target.textContent;
                    const mappingItem = editorPanel.querySelector('.mapping-item');

                    // Determine the correct input to target. Use the last focused input if it's
                    // within the current mapping item, otherwise fall back to the first input.
                    let input = null;
                    if (lastFocusedInput && mappingItem.contains(lastFocusedInput)) {
                        input = lastFocusedInput;
                    } else {
                        input = mappingItem.querySelector('.template-input');
                    }

                    if (!input) return;
                    
                    // Insert the field at the current cursor position in the determined input
                    const start = input.selectionStart;
                    const end = input.selectionEnd;
                    const text = input.value;
                    input.value = text.substring(0, start) + field + text.substring(end);
                    input.focus();
                    input.selectionStart = input.selectionEnd = start + field.length;
                }
            });

            // Add a focus listener to the container to track the last active input
            editorPanel.addEventListener('focusin', (e) => {
                if (e.target.classList.contains('template-input')) {
                    lastFocusedInput = e.target;
                }
            });

            // Save changes to the in-memory object whenever the user types
            editorPanel.addEventListener('input', (e) => {
                if (e.target.classList.contains('template-input')) {
                    updateMappingsFromUI();
                }
            });

            // Initial load
            loadMappings();
        });
    </script>
</body>

</html>